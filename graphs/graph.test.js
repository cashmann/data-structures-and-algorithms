'use strict';

const Graph = require('./graph');

describe('Graph', ()=>{
  it('can add a vertex', ()=>{
    let graph = new Graph();
    graph.addVertex('n');
    expect(graph.vertices[0]).toBe('n');
    graph.addVertex('m');
    expect(graph.vertices[1]).toBe('m');
    graph.addVertex('a');
    graph.addVertex('b');
    graph.addVertex('c');
    graph.addVertex('d');
    graph.addVertex('e');
    graph.addVertex('f');
    graph.addVertex('g');
    expect(graph.vertices).toContain('n', 'm');
    expect(function(){graph.addVertex('a');}).toThrow(Error);
  });
  it('can add edges', ()=>{
    let graph = new Graph();
    graph.addVertex('n');
    expect(graph.vertices[0]).toBe('n');
    graph.addVertex('m');
    expect(graph.vertices[1]).toBe('m');
    graph.addVertex('a');
    graph.addVertex('b');
    graph.addVertex('c');
    graph.addVertex('d');
    graph.addVertex('e');
    graph.addVertex('f');
    graph.addVertex('g');
    expect(graph.vertices).toContain('n', 'm');
    graph.connect(graph.vertices[1], graph.vertices[5], 5);
    expect(graph.edges['m'][0]).toEqual(['d', 5]);
    graph.connect('m', 'b', 5);
    expect(graph.edges['m'].length).toBe(2);
    console.log(graph.edges['m']);
    expect(graph.edges['b'][0]).toContain('m');
    graph.connect('b', 'q', 1);
    expect(graph.edges['q']).toBeDefined();
    expect(function(){graph.connect('m', 'm');}).toThrow(Error);

  });
  it('can return all values of a graph using BFT', ()=>{
    let graph = new Graph();
    graph.addVertex('n');
    expect(graph.vertices[0]).toBe('n');
    graph.addVertex('m');
    expect(graph.vertices[1]).toBe('m');
    graph.addVertex('a');
    graph.addVertex('b');
    graph.addVertex('c');
    graph.addVertex('d');
    graph.addVertex('e');
    graph.addVertex('f');
    graph.addVertex('g');
    expect(graph.vertices).toContain('n', 'm');
    graph.connect(graph.vertices[1], graph.vertices[5], 5);
    expect(graph.edges['m'][0]).toEqual(['d', 5]);
    graph.connect('m', 'b', 5);
    expect(graph.edges['m'].length).toBe(2);
    console.log(graph.edges['m']);
    expect(graph.edges['b'][0]).toContain('m');
    console.log(graph.bft());
    expect(graph.bft().length).toBe(1);
    graph.connect('m', 'n', 1);
    graph.connect('n', 'a', 2);
    graph.connect('a', 'b', 3);
    graph.connect('c', 'b', 4);
    graph.connect('c', 'f', 5);
    graph.connect('m', 'f', 6);
    graph.connect('f', 'b', 7);
    graph.connect('e', 'f', 8);
    graph.connect('g', 'd', 9);
    graph.connect('g', 'a',10);
    console.log(graph.bft());
    let array = graph.bft();
    expect(array.length).toBe(9);
    expect(array).toContain('a', 'b', 'c', 'd', 'e', 'f', 'g', 'n', 'm');
  });
  it('can add edge weights together', ()=>{
    let graph = new Graph();
    graph.addVertex('n');
    expect(graph.vertices[0]).toBe('n');
    graph.addVertex('m');
    expect(graph.vertices[1]).toBe('m');
    graph.addVertex('a');
    graph.addVertex('b');
    graph.addVertex('c');
    graph.addVertex('d');
    graph.addVertex('e');
    graph.addVertex('f');
    graph.addVertex('g');
    expect(graph.vertices).toContain('n', 'm');
    graph.connect(graph.vertices[1], graph.vertices[5], 5);
    expect(graph.edges['m'][0]).toEqual(['d', 5]);
    graph.connect('m', 'b', 5);
    expect(graph.edges['m'].length).toBe(2);
    expect(graph.edges['b'][0]).toContain('m');
    expect(graph.bft().length).toBe(1);
    graph.connect('m', 'n', 1);
    graph.connect('n', 'a', 2);
    graph.connect('a', 'b', 3);
    graph.connect('c', 'b', 4);
    graph.connect('c', 'f', 5);
    graph.connect('m', 'f', 6);
    graph.connect('f', 'b', 7);
    graph.connect('e', 'f', 8);
    graph.connect('g', 'd', 9);
    graph.connect('g', 'a',10);
    let weight = graph.getWeight('n', 'a');
    expect(weight[1]).toBe(2);
    expect(function(){graph.getWeight('n','n');}).toThrow(Error);
    expect(function(){graph.getWeight('n');}).toThrow(Error);
    expect(function(){graph.getWeight('q', 'n');}).toThrow(Error);
    expect(function(){graph.getWeight('n', 'a', 'q');}).toThrow(Error);
    weight = graph.getWeight('n', 'a', 'b');
    expect(weight[1]).toBe(5);
  });
  it('can traverse itself depth-first', ()=>{
    let graph = new Graph();
    graph.addVertex('n');
    expect(graph.vertices[0]).toBe('n');
    graph.addVertex('m');
    expect(graph.vertices[1]).toBe('m');
    graph.addVertex('a');
    graph.addVertex('b');
    graph.addVertex('c');
    graph.addVertex('d');
    graph.addVertex('e');
    graph.addVertex('f');
    graph.addVertex('g');
    expect(graph.vertices).toContain('n', 'm');
    graph.connect(graph.vertices[1], graph.vertices[5], 5);
    expect(graph.edges['m'][0]).toEqual(['d', 5]);
    graph.connect('m', 'b', 5);
    expect(graph.edges['m'].length).toBe(2);
    expect(graph.edges['b'][0]).toContain('m');
    expect(graph.bft().length).toBe(1);
    graph.connect('m', 'n', 1);
    graph.connect('n', 'a', 2);
    graph.connect('a', 'b', 3);
    graph.connect('c', 'b', 4);
    graph.connect('c', 'f', 5);
    graph.connect('m', 'f', 6);
    graph.connect('f', 'b', 7);
    graph.connect('e', 'f', 8);
    graph.connect('g', 'd', 9);
    graph.connect('g', 'a',10);
    let array = graph.dft('m');
    expect(array.length).toBe(9);
    expect(function(){graph.dft('q');}).toThrow(Error);
    graph.addVertex('z');
    array = graph.dft('z');
    expect(array.length).toBe(1);
  });
});